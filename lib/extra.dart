import 'automaton.dart';
import 'automaton_generator.dart';
import 'helper.dart';
import 'state.dart';

State automaton(
  String type,
  State state,
  String template, {
  String? accept,
  String placeholder = '{{@state}}',
  String? reject,
  String result = 'null',
  Map<String, String> values = const {},
}) {
  final automaton = Automaton(
    accept: accept,
    reject: reject,
    result: result,
    template: template,
  );
  final generator = AutomatonGenerator(automaton);
  final start = generator.generate(type, state, values: values);
  return start;
}

/// Creates a [State] that generates code to isolate variables, creating a scope
/// for the code generated by [state].
State block(State state) {
  final type = state.type;
  if (type.trim() == 'void') {
    const template = '''
final {{tmp}} = false;
{{@state}}
if ({{tmp}}) {
  {{@accept}}
}
{{@reject}}
''';
    const automaton = Automaton(
      accept: '{{tmp}} = true;',
      template: template,
    );
    const generator = AutomatonGenerator(automaton);
    final start = generator.generate(type, state);
    return start;
  } else {
    const template = '''
var ({{type}})? {{tmp}};
{{@state}}
if ({{tmp}} != null) {
  {{@accept}}
}
{{@reject}}
''';
    const automaton = Automaton(
      accept: '{{tmp}} = ({{0}},);',
      result: '{{tmp}}.\$1',
      template: template,
    );
    const generator = AutomatonGenerator(automaton);
    final start = generator.generate(type, state, values: {'type': type});
    return start;
  }
}

State functionBody(
    String type, State state, String acceptResult, String rejectResult) {
  const template = '''
{{@state}}
''';

  final automaton = Automaton(
    accept: 'return $acceptResult;',
    reject: 'return $rejectResult;',
    template: template,
  );

  final generator = AutomatonGenerator(automaton);
  final start = generator.generate(type, state);
  return start;
}

/// Creates a [State] that generates code that will accumulate the results of
/// the computation [state] in a list. Returns a list of those results even if
/// the result list is empty.
State many(State state) {
  const template = '''
final {{list}} = <{{type}}>[];
while (true) {
  {{@state}}
}
{{@accept}}
''';
  const automaton = Automaton(
    accept: '{{list}}.add({{0}});\ncontinue;',
    reject: 'break;',
    result: '{{list}}',
    template: template,
  );
  final elementType = state.type;
  final type = 'List<$elementType>';
  const generator = AutomatonGenerator(automaton);
  final start = generator.generate(type, state, values: {'type': elementType});
  return start;
}

/// Creates a [State] that generates code that will accumulate the results of
/// the computation [state] in a list. If at least one result is available, it
/// will return a list of those results, otherwise it will reject.
State many1(State state) {
  const template = '''
final {{list}} = <{{type}}>[];
while (true) {
  {{@state}}
}
if ({{list}}).isNotEmpty {
  {{@accept}}
}
{{@reject}}
''';
  const automaton = Automaton(
    accept: '{{list}}.add({{0}});\ncontinue;',
    reject: 'break;',
    result: '{{list}}',
    template: template,
  );
  final elementType = state.type;
  final type = 'List<$elementType>';
  const generator = AutomatonGenerator(automaton);
  final start = generator.generate(type, state, values: {'type': elementType});
  return start;
}

/// Creates a [State] that generates code that will transform the result of the
/// computation [state].
///
/// To use the result in a transformation expression, result access placeholders
/// are available.
///
/// The result access placeholders look like `{{n}}`, where `n` is the index.
///
///
/// When used with sequences, the index corresponds to the result of the
/// corresponding sequence element, in all other cases the result value is not
/// multiple and the index can only be 0.
///
/// Example:
///
/// ```dart
/// final s1 = seq([
///   s(1),
///   s(2),
///   s(3),
///  ]);
/// final s0 = map('String', s1, '"{{0}}{{1}}{{2}}"');
/// ```
///
///
State map(String type, State state, String expression) {
  state.listenToAcceptors((acceptor, allocate) {
    var result = expression;
    if (state is SequenceState) {
      final states = state.states;
      for (var i = 0; i < states.length; i++) {
        final state = states[i];
        result = result.replaceAll('{{$i}}', state.result);
      }
    } else {
      result = result.replaceAll('{{0}}', acceptor.result);
    }

    final v = allocate('v');
    final acceptance = '''
final $v = $result;
{{@accept}}''';
    acceptor.renderAcceptance(acceptance);
    acceptor.result = v;
    state.type = type;
  });

  return state;
}

/// Creates a [State] that generates code that will multiplex the results of
/// computations from different branches into one computation point,
/// transforming multiple inputs computations into single output computation.
///
/// This function is used internally by the [Sequence] to prevent duplication of
/// the generated code. All elements of the [Sequence], except the last element,
/// if they generate a computation with multiple outputs, are transformed into a
/// computation with single output.
State mux(State state) {
  final type = state.type.trim();
  if (type == 'void') {
    const template = '''
var {{tmp}} = false;
{{@state}}
if ({{tmp}}) {
  {{@accept}}
}
{{@reject}}
''';
    const automaton = Automaton(
      accept: '{{tmp}} = true;',
      reject: '',
      result: 'null',
      template: template,
    );
    const generator = AutomatonGenerator(automaton);
    final start = generator.generate(type, state);
    return start;
  } else {
    const template = '''
({{type}},)? {{tmp}};
{{@state}}
if ({{tmp}} != null) {
  {{@accept}}
}
{{@reject}}
''';
    const automaton = Automaton(
      accept: '{{tmp}} = ({{0}},);',
      reject: '',
      result: '{{tmp}}.\$1',
      template: template,
    );
    const generator = AutomatonGenerator(automaton);
    final start = generator.generate(type, state, values: {'type': type});
    return start;
  }
}

/// create a [State] that generates code that will return the result of the
/// computation [state] or `null`.
State optional(State state) {
  final type = getNullableType(state.type);
  final optional = ChoiceState(type, [state, value(type, 'null')]);
  return optional;
}

State procedureBody(String type, State state) {
  const template = '''
{{@state}}
''';

  final automaton = Automaton(
    accept: 'return;',
    template: template,
  );

  final generator = AutomatonGenerator(automaton);
  final start = generator.generate(type, state);
  return start;
}

State recognize(
  State state, {
  required String position,
  required String substring,
}) {
  const template = '''
final {{pos}} = {{position}};
var {{tmp}} = false;
{{@state}}
if ({{tmp}}) {
  final {{res}} = {{substring}}({{pos}}, {{position}});
  {{@accept}}
}
{{@reject}}
''';
  const automaton = Automaton(
    accept: '{{tmp}} = true;',
    reject: '',
    result: '{{res}}',
    template: template,
  );
  const generator = AutomatonGenerator(automaton);
  final start = generator.generate('String', state, values: {
    'position': position,
    'substring': substring,
  });
  return start;
}

State skipMany(State state) {
  const template = '''
while (true) {
  {{@state}}
}
{{@accept}}
''';
  const automaton = Automaton(
    accept: 'continue;',
    reject: 'break;',
    result: 'null',
    template: template,
  );
  const generator = AutomatonGenerator(automaton);
  final start = generator.generate('void', state);
  return start;
}

State skipMany1(State state) {
  const template = '''
var {{tmp}} = false;
while (true) {
  {{@state}}
}
if ({{tmp}}) {
  {{@accept}}
}
{{@reject}}
''';
  const automaton = Automaton(
    accept: '{{tmp}} = true;\ncontinue;',
    reject: 'break;',
    result: 'null',
    template: template,
  );
  const generator = AutomatonGenerator(automaton);
  final start = generator.generate('void', state);
  return start;
}

State value(String type, String value) {
  const template = '''
{{@accept}}
''';
  final state = OperationState(type, template, result: value);
  return state;
}
